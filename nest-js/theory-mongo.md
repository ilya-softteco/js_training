* Построение коллекций
``db.createCollection('temps')``
```
    
     В MongoDB коллекции используются для хранения документов.
     Они аналогичны таблицам в реляционных базах данных.
     Вот некоторые ключевые моменты о коллекциях в MongoDB:
     
     
     1.Создание коллекции: Для создания коллекции в MongoDB используется метод db.createCollection().
     Например, db.createCollection('myCollection').
     MongoDB автоматически создает коллекцию при первом обращении к ней в команде.
     Это означает, что вы можете просто начать добавлять документы в коллекцию, и MongoDB создаст ее за вас.
    
     2.Определение полей: В MongoDB вы можете создать коллекцию с определенными полями, используя команду insertOne().
    
     3.Типы данных: MongoDB поддерживает различные типы данных, включая
      String, Integer, Double, Boolean, Null, Array, Object, ObjectId, Undefined, Binary Data,
      Date, Int32, Long и Decimal128
    
 
```
* Связи коллекций

```
db.users.insertOne({
    firstName: 'Ilya',
    lastName: 'Martinkevich',
    age: 24,
    posts: [
        {
        name: 'Post 1',
        description: 'Description 1',
       },
       {
        name: 'Post 2',
        description: 'Description 2',
        }
       ]
})
```

```
    В MongoDB существуют два основных способа представления связей между документами: встроенные документы и ссылки

    1.Встроенные документы (Embedded Documents): В этой модели документы вкладываются внутрь одного документа.
      Например, если у вас есть два документа, один для студента (содержащий основную информацию о студенте, такую как id, имя, филиал) и другой для адреса (содержащий адрес студента), вы можете встроить документ адреса внутрь документа студента.
      Это позволяет извлекать данные с помощью одного запроса, а не нескольких.
   
    2.Ссылки (References): В этой модели документы поддерживаются отдельно, но один документ содержит ссылки на другие документы2. Например, документ студента может содержать ссылку на id поля документа адреса.
      Используя эту ссылку, вы можете запросить адрес и получить адрес студента2. Эта модель обычно используется для проектирования нормализованных отношений2.
```

* Индексы
    
```
  db.users.createIndex({"name" : 1})
```

```
Индексы в MongoDB играют важную роль для эффективного выполнения запросов. Они позволяют упорядочить данные по определенному полю, что ускоряет поиск

Типы индексов:
Одно поле
Составной индекс
Multikey индексы -- MongoDB использует multikey для индексации содержимого, хранящегося в массивах. В таких индексах допускается несколько записей в массиве указывающих на один и тот же документ. К примеру есть документ с несколькими тегами:

Уникальные индексы — Уникальное свойство для индекса заставляет MongoDB отклонять повторяющиеся значения для проиндексированного поля. Помимо уникального ограничения, уникальные индексы функционально взаимозаменяемы с другими индексами MongoDB.
    db.users.createIndex(
            { email: 1 },
            { unique: true }
                )
   
    *Геопространственные индексы (Geospatial Index): Они улучшают производительность запросов на геопространственные координатные данные2. MongoDB предоставляет два типа геопространственных индексов: 2d индексы, которые используют планарную геометрию для возврата результатов, и 2dsphere индексы, которые используют сферическую геометрию для возврата результатов2.
    *Текстовые индексы (Text Index): Они поддерживают текстовые поисковые запросы на полях, содержащих строковый контент2.
    *Хешированные индексы (Hashed Index): Они поддерживают хешированное шардирование. Хешированные индексы индексируют хеш-значение поля2.
    *Кластерные индексы (Clustered Index): Они определяют порядок, в котором кластерные коллекции хранят данные2.
       
      
                
```

```
Метод db.aggregate() в MongoDB используется для выполнения операций агрегации с использованием конвейера агрегации.
Конвейер агрегации позволяет пользователям обрабатывать данные из коллекции или другого источника
с помощью последовательности манипуляций на основе этапов.
Операции агрегации в MongoDB обрабатывают данные и возвращают вычисленные результаты.
```

* Операция $lookup в MongoDB позволяет пользователям объединять поля из документов в двух коллекциях. Эта операция аналогична операции JOIN в SQL

```
    db.users.aggregate([
        {
            $lookup: {
                from: "users",
                localField: '_id',
                foreignField: "_id",
                as: "posts"
            }
        }
    ])
```

* В MongoDB оператор **$project** используется в агрегационном конвейере и служит для передачи документов со специфическими полями на следующую стадию конвейера
  Если говорить об аналогии с SQL, то $project в MongoDB можно сравнить с оператором SELECT в SQL. В SQL вы используете SELECT, чтобы указать, какие столбцы вы хотите получить в результате запроса. Аналогично, в MongoDB вы используете $project, чтобы указать, какие поля вы хотите получить в результате агрегации.

  Однако стоит отметить, что $project в MongoDB обладает большей гибкостью по сравнению с SELECT в SQL, поскольку он позволяет не только выбирать существующие поля, но и создавать новые поля, вычисляемые на основе существующих

``` 
        db.users.aggregate([
        {
            $project: {
                _id: 1,
                nameEmail: {
                    $concat: ["$email", "-", "$name"]
                },
            }
        }
        ]); 
```

* Оператор **$match** в MongoDB используется в агрегационном конвейере для фильтрации документов.
  Этот оператор принимает документ, который указывает условия запроса. Синтаксис запроса для $match идентичен синтаксису запроса для операции чтения.

    Если говорить об аналогии с SQL, то $match в MongoDB можно сравнить с оператором WHERE в SQL. В SQL вы используете WHERE для фильтрации строк в результате запроса. Аналогично, в MongoDB вы используете $match для фильтрации документов в агрегационном конвейере.


```
db.users.aggregate(
    [
        {
            $match: {
                age: {
                    $lte: 5
                }
            }
        }
    ]
);
```

*   Оператор $set в MongoDB может использоваться как в агрегационном конвейере, так и в операциях обновления, но его поведение в этих контекстах немного отличается

    **$set в агрегационном конвейере**: Начиная с MongoDB 4.2, $set можно использовать в агрегационном конвейере. Он добавляет новые поля к документам $set выводит документы, которые содержат все существующие поля из входных документов и вновь добавленные поля. Оператор $set в агрегационном конвейере является псевдонимом для $addFields.
        Оператор $set в агрегационном конвейере MongoDB не изменяет исходные документы в коллекции12. Вместо этого, он просто изменяет форму документов, которые передаются на следующую стадию конвейера12. Это означает, что после выполнения вашего запроса aggregate, исходные документы в коллекции users не будут изменены, и новое поле newField не будет добавлено к этим документам
    
```
    
db.users.aggregate([
    {
        $match: {_id: ObjectId('6636bd16f5d893268dfe36cf')}
    },
    {
        $set: {newField: "newValue"}
    }
])
```
*    **$set в операциях обновления**: В операциях обновления $set заменяет значение поля на указанное значение. Если поле не существует, $set добавит новое поле с указанным значением3. Если вы указываете путь с точками для несуществующего поля, $set создаст вложенные документы, которые необходимы для выполнения пути с точками к полю3.
        
```
        db.users.updateOne(
            {
                _id: ObjectId('6636bd16f5d893268dfe36cf')
            },
            {
                $set: {age: 20}
            }
        )
```



* Оператор **$unwind** в MongoDB используется для деконструкции поля массива в документе и создания отдельных выходных документов для каждого элемента в массиве.
Каждый выходной документ является входным документом со значением поля массива, замененным на элемент.

    В SQL, аналогом $unwind может быть операция CROSS JOIN. В SQL вы можете “раскрутить” массив, применив CROSS JOIN к таблице и ее столбцу-массиву. Это приведет к созданию новой строки для каждого элемента массива

```

    db.clothing.insertMany([
        { "_id" : 1, "item" : "Shirt", "sizes": [ "S", "M", "L"] },
        { "_id" : 2, "item" : "Shorts", "sizes" : [ ] },
        { "_id" : 3, "item" : "Hat", "sizes": "M" },
        { "_id" : 4, "item" : "Gloves" },
        { "_id" : 5, "item" : "Scarf", "sizes" : null }
    ])



    db.clothing.aggregate(
        [
            {
                $unwind: "$sizes"
            }
        ]
       )
       
       RESULT:
       
        [
          {
            "_id": 1,
            "item": "Shirt",
            "sizes": "S"
          },
          {
            "_id": 1,
            "item": "Shirt",
            "sizes": "M"
          },
          {
            "_id": 1,
            "item": "Shirt",
            "sizes": "L"
          },
          {
            "_id": 3,
            "item": "Hat",
            "sizes": "M"
          }
        ]
```


* Оператор $replaceRoot в MongoDB используется в стадии агрегации для замены входного документа на указанный документ.
  Это позволяет вам изменить структуру документов в коллекции MongoDB, продвигая значение указанного вложенного поля на верхний уровень.
  Операция заменяет все существующие поля во входном документе, включая поле _id
  Аналогом $replaceRoot в SQL может быть операция SELECT INTO. В SQL вы можете “перестроить” таблицу, создав новую таблицу на основе выборки из существующей.
  Это приведет к созданию новой таблицы с полями, выбранными из существующей
```

    db.temp.insertMany([
        {
            "_id": 1, "name": "John", "details": {"age": 30,  "address": "123 Street, City, Country" }
        },
        {
            "_id": 2,  "name": "Jane", "details": {"age": 25,  "address": "456 Avenue, City, Country"  }
        }
    ])
    
    db.temp.aggregate([
        {
            $replaceRoot: { newRoot: "$details" }
        }
    ])

        
        RESULT:
        
    [
      {
        "address": "123 Street, City, Country",
        "age": 30
      },
      {
        "address": "456 Avenue, City, Country",
        "age": 25
      }
    ]
```

* Вложенные запросы 

``` 
  Для выполнения вложенных запросов в mongodb можно использовать $elemMatch,
  если данные(данные должны быть в виде массива) находятся 
  в одной и тойже коллекции или $lookup , если данные находятся в разных коллекцях 
  
  
    db.students.insertMany([
      {
          "_id": 1,
          "name": "John",
          "scores": [{"subject": "math", "score": 85}, {"subject": "english", "score": 90}]
      },
      {
          "_id": 2,
          "name": "Jane",
          "scores": [{"subject": "math", "score": 95}, {"subject": "english", "score": 85}]
      },
      {
          "_id": 3,
          "name": "Bob",
          "scores": [{"subject": "math", "score": 80}, {"subject": "english", "score": 88}]
      }
    ])
  
  
  db.students.find({
      "scores": {
          $elemMatch: {
              "subject": "math",
              "score": {$gte: 85}
          }
      }
  })
```